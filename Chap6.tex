\section{Algorithm}
$n1$ sessions are established before the data forwarding takes place. These sessions remain established throughout the run.

$n2$ sessions are established, modified and released while the data forwarding is also taking place. The data packets are sent from all the currently established sessions. The minimum value of currently established sessions is $n1$. The maximum value is $n1+n2$.

$t1$ is the total duration of the experiment.
$t2$ is the  duration of the establishment, modification and release cycle of each of the $n2$ sessions.

The duration $t1$ for which all the static sessions $n1$ and the dynamic sessions $n2$ are used is also asked to the user.

Data forwarding starts from the $n1$ sessions at the start. After sleeping for a time (currently 5
seconds), $n2$ threads are started. The role of each thread is to sleep for a random amount of time
$t3$ ($<t2$), establish and modify the session, and then sleep for some time $t4$ and release the
session. The invariant is $t3+t4= t2$.   The session is available for data forwarding in the period $t4$.  The threads with new session Ids are started once all the previous threads have joined i.e. have finished their task.
Each of the data packet forwarding cores use all the existing established sessions/UEs to forward the data. Note that this is different from the case when sessions were partitioned among cores.

\section{Issues}
\begin{itemize}
	\item \textbf{Pthreads vs. Lthreads}
	There are two kind of threading models available - Pthreads and Lthreads.
	\begin{itemize}
		\item \textbf{Pthreads} This model is fully implemented and works correctly when locks are used in both data plane and control plane functions. The names of control plane procedures to be used in this model end with `Pthread'.
		\item \textbf{Lthreads} DPDK has lthread API available for spawning threads on the 
		same core. This is a user space threading API with a user space scheduler. This is 
		not preemptive and is based on cooperative scheduling -threads yield control for 
		scheduler to schedule another thread. This yielding happens on certain points when 
		functions like \textbf{lthread\_sleep} are called. An alternate set of control plane procedures for defining the dynamic session functionality is defined on an experimental basis. This may be used if there are performance hits in pthread implementation.
	\end{itemize}
	\item Data plane latency packets are currently sent only from first $n1$ sessions. The dynamically created sessions ($n2$) are used to send data but not the latency packets.

\end{itemize}
